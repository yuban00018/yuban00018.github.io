---
title: 面向对象程序设计第一周（从C到C++ A）
---
## 定义和声明的区别

### 定义-程序执行时分配相应的内存单元
1. 定义变量意味着该变量分配内存单元
2. 函数定义：程序运行时，函数代码存放在内存中（冯诺依曼“储存程序原理”）
### 声明 描述-不涉及内存分配
1. 外部参照类型(extern)变量声明
2. 引用
3. 函数原型声明
4. 结构体数据组织形式
5. 函数模板，类模板

ps：多用引用而不是指针
## 左值与右值
1. 左值-具有存储单元的量，并且该单元可写
2. 右值-其值可以被读取的量

左值本质是变量，之所以称为"左值"是因为它可以出现在赋值运算的左侧

```C++
int x = 0;
++x;
--x;
//左值
x++;
x--;
/*
不能为左值
可能和编译器有关
*/
```

## 变量
值在运行过程中可以改变的量，必须先定义后使用（定义意味着分配内存空间），满足五要素：
1. 储存类型 （生命期，可见性）
2. 数据类型（储存格式，取值范围）
3. 变量名
4. 变量初始值
5. 变量地址（这个由系统决定）

## 变量定义格式
定义语句：
```C++
储存类型 数据类型 变量名 = 初始化值;
```
### 在所有的函数之外
1. 全局变量 储存类型 缺省 存放在全局数据区
2. 静态全局 储存类型 static 存放在全局数据区
### 在函数之内
1. 静态局部 储存类型 static 存放在全局数据区(常量池)
2. 局部自动变量 储存类型 auto 或者 缺省 存放在栈区
   
p.s. static 只在定义的作用域存在并可见，在外面存在但不可见

## 变量储存类型
### 代码区（code area）
存放程序代码
### 数据区
#### 全局数据区、常量池（data area）
1. 存放全局变量、静态全局变量
2. 静态局部变量、常量
#### 栈区（stack area）
1. 存放局部（自动）变量
#### 堆区（heap area）
1. 存放动态变量

## 全局变量
在所有函数之外定义、缺省存储类型的变量称为全局变量。

优点：
1. 全局变量存在全局数据区
2. 全局变量在主函数执行之前产生、主函数结束后销毁（生命期是全局的）
3. 全局变量定义语句之后的所有函数中均可以直接对其进行读取访问（作用域范围大，可见性强）

缺点：
1. 不利于维护，移植（不建议程序中使用全局变量）

## 静态全局变量
在所有函数之外定义，储存类型为 static 的变量称为静态全局变量。
### 静态全局变量与全局变量的唯一区别
1. 在多文件结构程序中，静态全局变量的作用域仅现定于定义其的源文件（称**编译单元**）中，不能跨越源程序文件
2. 全局变量可以跨越不同的源程序文件。需要在某一个源程序文件中定义（分配内存空间），而在其他源程序中使用“外部参照访问声明”即可：
```C++
extern 数据类型 某全局变量名;
```
即：一处定义，多处声明。

## 局部静态变量
在函数内定义，储存类型为 static 的变量。
1. 静态局部变量存放在全局数据区
2. 静态局部变量可能不被创建
（程序运行时始终不执行定义它的函数）

## 局部变量（自动变量）
在函数内定义，储存类型为 auto 的变量称为局部变量，也称为自动变量。
1. 局部变量是程序中使用最多的变量
2. 局部变量存放在栈区
3. 生命期：随调用创建，函数返回后销毁
4. 可见性：仅函数内部
5. 初始化：定义时如果未对其显式初始化，初始值不可预知。

注：全局变量，静态全局变量，静态局部变量在定义时，若未对其显式初始化，系统自动初始化为各位全0.

## 变量的数据类型
变量的数据类型决定了存放格式
1. 占用字节数
2. 取值范围
3. 可执行的运算

变量定义时所规定的数据类型不会改变
1. 类型的强制变化，类型自动转换运算仅仅将变量作为右值。
```C++
double x = 5.6;
cout<<int(x)<<'&'<<x<<endl;
```

## 变量的值
1. 初值：变量定义时对其初始化，使创建时就具有值。
2. 当前值：生命周期内，变量值的变化代表求解的历程。
3. 变量的控制（编写程序）：将本质上互相独立的变量有机地组织起来，协同完成计算任务。
4. 变量的控制（阅读程序）：跟踪多个逻辑上相关的变量值的协同变化规律。

## 变量地址
### 变量在储存区域中的具体地址由系统安排
1. 从生命开始到生命期结束，地址值不变
2. 自动变量重新创建时，地址值可能改变

## 变量名
### 实际问题与计算机内存之间的桥梁
1. 表达实际事物的数量
2. 代表计算机内存单元
   
变量名是上述两方面的抽象记号，计算机内存单位是实体

### 变量的引用
变量的应用是变量实体（一个已经存在的变量）的一个别名
```C++
数据类型 & 引用名 = 已存在的变量名;
```
1. 变量的引用只是声明，不是定义，不会另外分配内存空间(长称：引用不占空间)
2. 声明引用时，必须用一个变量实体对其初始化
3. 这样的绑定从引用声明开始，一直到引用声明的生命期结束，**不能更改**！
4. 给变量绑定后赋值一个变量，更改的是引用对象的值

### 常量的应用
可以对字面常量，符号常量，甚至变量取别名
```C++
const 数据类型 & 引用名称 = 常量；
const 数据类型 & 引用名 = 已存在的变量名;
//可以将变量视为常量，但不能将常量作为变量
```

### 引用的绑定
```C++
double x = 2.5;
const double PI = 3.1415926;
const double &rPI = 1/PI, &E = 2.71821828;
const double &rx = x;
cout << rx << endl;
x++;//valid
rx++;//invalid
cout << x << endl;
cout << rx << endl;
double &r = PI;//invalid
```

要求：函数参数都用引用

## 函数
### 函数原型
1. 编译器检查程序中调用函数语句正确性的依据
2. 程序员写调用函数语句的依据
### 函数定义
1. 函数功能的具体实现
2. 是连接器链接目标代码、函数库的依据
### 函数调用
1. 实际使用函数，必要时童工代加工的实际数据（被称为实际参数）

## 函数的形式参数
### 无形式参数
1. 调用函数时不提供实际参数，但不能缺少圆括号。
### 传值型
函数调用时，将创建形参变量
1. 为形式参数变量分配自己的内存空间
2. 用实际参数（表达式）的值初始化形参变量
3. 新创建的形参变量放在栈空间中，函数返回时销毁
4. 函数体内队形参的操作与实参无关。
### 引用型
函数调用时，不创建变量，形参为实参的别名
1. 形参不占用内存空间
2. 用实参初始化形参的引用声明
3. 引用型形参“绑定”实参，直到函数返回
4. 函数体内队形参的操作就是对实参的操作（与实参相关）

## 函数返回值优化
编译器关于返回值优化 -- [RVO](https://zh.wikipedia.org/wiki/返回值优化)（Return Value Optimization）

```C++
#include <iostream>
using namespace std;

class TestRVO
{
public:
	TestRVO(int x=0):a(x){ cout << "构造对象(" << a << ')' << endl; }
	TestRVO(const TestRVO &r):a(r.a){ cout << "拷贝构造对象(" << a << ')' << endl; }
	~TestRVO() { cout << "析构对象(" << a << ')' << endl; }
private:
	int a;
};

TestRVO f(int a)			// 值返回
{
	TestRVO x(a);			// 局部自动对象，生命期为局部的，故只能采用值返回
	cout << "in f()..." << endl;
	return x;
}

TestRVO & g(int a)			// 引用返回
{
	static TestRVO x(a);	// 静态局部对象，生命期为全局的，故可以将该变量引用返回
	cout << "in g()..." << endl;
	return x;
}

int main()
{
	cout << "f(100)" << endl;
	f(100);
	cout << "\ng(200)" << endl;
	g(200);
	cout << "return to Operating System." << endl;
	return 0;
}
```
**运行结果**：
```
---------使用返回值优化（默认）--------
f(100)
构造对象(100)
in f()...
析构对象(100)

g(200)
构造对象(200)
in g()...
return to Operating System.
析构对象(200)

---------不使用返回值优化--------------
f(100)
构造对象(100)
in f()...
拷贝构造对象(100)
析构对象(100)
析构对象(100)

g(200)
构造对象(200)
in g()...
return to Operating System.
析构对象(200)
```

返回值的函数调用，将会创造一个零时的无名变量（该变量用调用表达式表示）例如sqrt(2.0)表达式本身表示一个无名变量，类型 double ，值 1.414。然而，编译器默认返回值优化，可能不创造该临时无名变量。若要求不使用返回值优化，应该添加编译器选项
```
-fno-elide-constructors
```
